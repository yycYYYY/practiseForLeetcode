package com.practice.P1_100.P31_40;

import java.util.HashSet;
import java.util.Set;

public class IsValidSudoku {
    /*
    NO.36 有效的数独(第二遍刷的时候，需要做下优化，当前太蠢了)
    判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

    数独部分空格内已填入了数字，空白格用 '.' 表示。
    示例 1:
    输入:
[
  ["5","3",'.','.',"7",'.','.','.','.'],
  ["6",'.','.',"1","9","5",'.','.','.'],
  ['.',"9","8",'.','.','.','.',"6",'.'],
  ["8",'.','.','.',"6",'.','.','.',"3"],
  ["4",'.','.',"8",'.',"3",'.','.',"1"],
  ["7",'.','.','.',"2",'.','.','.',"6"],
  ['.',"6",'.','.','.','.',"2","8",'.'],
  ['.','.','.',"4","1","9",'.','.',"5"],
  ['.','.','.','.',"8",'.','.',"7","9"]
]
    输出: true

    示例 2:
    输入:
[
  ["8","3",'.','.',"7",'.','.','.','.'],
  ["6",'.','.',"1","9","5",'.','.','.'],
  ['.',"9","8",'.','.','.','.',"6",'.'],
  ["8",'.','.','.',"6",'.','.','.',"3"],
  ["4",'.','.',"8",'.',"3",'.','.',"1"],
  ["7",'.','.','.',"2",'.','.','.',"6"],
  ['.',"6",'.','.','.','.',"2","8",'.'],
  ['.','.','.',"4","1","9",'.','.',"5"],
  ['.','.','.','.',"8",'.','.',"7","9"]
]
    输出: false
    解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
        但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

    说明:
    一个有效的数独（部分已被填充）不一定是可解的。
    只需要根据以上规则，验证已经填入的数字是否有效即可。
    给定数独序列只包含数字 1-9 和字符 '.' 。
    给定数独永远是 9x9 形式的。
     */

    /*
    对于本题的第一思路肯定是最简单的暴力破解，分别对，行、列、九宫格做有效性验证，但这个解法太蠢了
    不过虽然蠢，但是有效。。。。。
     */
    boolean solution(char[][] board){
        Set rows = new HashSet<Integer>();
        Set cols = new HashSet<Integer>();
        Set nums = new HashSet<Integer>();

        for(int i = 0;i < 9;i++){
            for (int j = 0;j < 9;j++){
                if (board[i][j] != '.'){
                    if (rows.contains(board[i][j])) return false;
                    rows.add(board[i][j]);
                }
                if (board[j][i] != '.'){
                    if (cols.contains(board[j][i])) return false;
                    cols.add(board[j][i]);
                }
            }
            rows.clear();
            cols.clear();
        }

        for (int a = 0;a < 9;a += 3){
            int maxRow = a + 3;
            for (int b = 0;b < 9;b += 3){
                int maxCol = b + 3;
                for (int i = a;i < maxRow;i++){
                    for (int j = b;j < maxCol;j++){
                        if (board[i][j] != '.'){
                            if (nums.contains(board[i][j])) return false;
                            nums.add(board[i][j]);
                        }
                    }
                }
                nums.clear();
            }
        }

        return true;
    }

    public static void main(String[] args) {
        char[][] a = {
                {5,3,'.','.',7,'.','.','.','.'},
                {6,'.','.',1,9,5,'.','.','.'},
                {'.',9,8,'.','.','.','.',6,'.'},
                {8,'.','.','.',6,'.','.','.',3},
                {4,'.','.',8,'.',3,'.','.',1},
                {7,'.','.','.',2,'.','.','.',6},
                {'.',6,'.','.','.','.',2,8,'.'},
                {'.','.','.',4,1,9,'.','.',5},
                {'.','.','.','.',8,'.','.',7,9}};

        IsValidSudoku i = new IsValidSudoku();
        boolean res = i.solution(a);
        System.out.println(res);
    }
}
