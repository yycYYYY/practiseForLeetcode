package com.practice.p1_100.P31_40;

import java.util.HashSet;
import java.util.Set;
/**
 NO.36 有效的数独(第二遍刷的时候，需要做下优化，当前太蠢了)
 判断一个9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

 数字1-9在每一行只能出现一次。
 数字1-9在每一列只能出现一次。
 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。

 数独部分空格内已填入了数字，空白格用'.'表示。
 示例1:
 输入:
[
        ["5","3",'.','.',"7",'.','.','.','.'],
        ["6",'.','.',"1","9","5",'.','.','.'],
        ['.',"9","8",'.','.','.','.',"6",'.'],
        ["8",'.','.','.',"6",'.','.','.',"3"],
        ["4",'.','.',"8",'.',"3",'.','.',"1"],
        ["7",'.','.','.',"2",'.','.','.',"6"],
        ['.',"6",'.','.','.','.',"2","8",'.'],
        ['.','.','.',"4","1","9",'.','.',"5"],
        ['.','.','.','.',"8",'.','.',"7","9"]
        ]
        输出: true

        示例2:
        输入:
        [
        ["8","3",'.','.',"7",'.','.','.','.'],
        ["6",'.','.',"1","9","5",'.','.','.'],
        ['.',"9","8",'.','.','.','.',"6",'.'],
        ["8",'.','.','.',"6",'.','.','.',"3"],
        ["4",'.','.',"8",'.',"3",'.','.',"1"],
        ["7",'.','.','.',"2",'.','.','.',"6"],
        ['.',"6",'.','.','.','.',"2","8",'.'],
        ['.','.','.',"4","1","9",'.','.',"5"],
        ['.','.','.','.',"8",'.','.',"7","9"]
        ]
        输出: false
        解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
        但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

        说明:
        一个有效的数独（部分已被填充）不一定是可解的。
        只需要根据以上规则，验证已经填入的数字是否有效即可。
        给定数独序列只包含数字1-9和字符'.'。
        给定数独永远是9x9形式的。
        */
public class IsValidSudoku {

    /*
    对于本题的第一思路肯定是最简单的暴力破解，分别对，行、列、九宫格做有效性验证，但这个解法太蠢了
    不过虽然蠢，但是有效。。。。。
     */
    boolean solution(char[][] board){
        Set rows = new HashSet<Integer>();
        Set cols = new HashSet<Integer>();
        Set nums = new HashSet<Integer>();

        for(int i = 0;i < 9;i++){
            for (int j = 0;j < 9;j++){
                if (board[i][j] != '.'){
                    if (rows.contains(board[i][j])) return false;
                    rows.add(board[i][j]);
                }
                if (board[j][i] != '.'){
                    if (cols.contains(board[j][i])) return false;
                    cols.add(board[j][i]);
                }
            }
            rows.clear();
            cols.clear();
        }

        for (int a = 0;a < 9;a += 3){
            int maxRow = a + 3;
            for (int b = 0;b < 9;b += 3){
                int maxCol = b + 3;
                for (int i = a;i < maxRow;i++){
                    for (int j = b;j < maxCol;j++){
                        if (board[i][j] != '.'){
                            if (nums.contains(board[i][j])) return false;
                            nums.add(board[i][j]);
                        }
                    }
                }
                nums.clear();
            }
        }

        return true;
    }

    public static void main(String[] args) {
        char[][] a = {
                {5,3,'.','.',7,'.','.','.','.'},
                {6,'.','.',1,9,5,'.','.','.'},
                {'.',9,8,'.','.','.','.',6,'.'},
                {8,'.','.','.',6,'.','.','.',3},
                {4,'.','.',8,'.',3,'.','.',1},
                {7,'.','.','.',2,'.','.','.',6},
                {'.',6,'.','.','.','.',2,8,'.'},
                {'.','.','.',4,1,9,'.','.',5},
                {'.','.','.','.',8,'.','.',7,9}};

        IsValidSudoku i = new IsValidSudoku();
        boolean res = i.solution(a);
        System.out.println(res);
    }
}
